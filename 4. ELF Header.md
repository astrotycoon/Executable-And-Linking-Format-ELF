# ELF Header
Some object file control structures can grow, because the ELF header contains their actual sizes. If the object file format changes, a program may encounter control structures that are larger or smaller than expected. Programs might therefore ignore ``extra'' information. The treatment of ``missing'' information depends on context and will be specified when and if extensions are defined.

ELF文件头结构就像是一个总览图，描述了整个文件的布局情况。

因此在ELF文件头结构允许的数值范围内，整个文件的大小是可以动态增减的。但是由于历史原因以及像C++这样的语言的发展，ELF文件头结构中有些数据成员的大小已经显得捉襟见肘，不足以表示现实世界中的ELF文件了。例如，表示程序头表表项个数的e_phnum和表示节头表表项个数的e_shnum的类型都是Elf32_Half，在32-bit和64-bit平台上都是16位的无符号数，也就是说最大数值为65536，那么问题来了，一旦超过这个数值怎么办？别急，继续看下文，总有解决办法的！

```C++
#define EI_NIDENT 16

typedef struct {
        unsigned char   e_ident[EI_NIDENT];
        Elf32_Half      e_type;
        Elf32_Half      e_machine;
        Elf32_Word      e_version;
        Elf32_Addr      e_entry;
        Elf32_Off       e_phoff;
        Elf32_Off       e_shoff;
        Elf32_Word      e_flags;
        Elf32_Half      e_ehsize;
        Elf32_Half      e_phentsize;
        Elf32_Half      e_phnum;
        Elf32_Half      e_shentsize;
        Elf32_Half      e_shnum;
        Elf32_Half      e_shstrndx;
} Elf32_Ehdr;

typedef struct {
        unsigned char   e_ident[EI_NIDENT];
        Elf64_Half      e_type;
        Elf64_Half      e_machine;
        Elf64_Word      e_version;
        Elf64_Addr      e_entry;
        Elf64_Off       e_phoff;
        Elf64_Off       e_shoff;
        Elf64_Word      e_flags;
        Elf64_Half      e_ehsize;
        Elf64_Half      e_phentsize;
        Elf64_Half      e_phnum;
        Elf64_Half      e_shentsize;
        Elf64_Half      e_shnum;
        Elf64_Half      e_shstrndx;
} Elf64_Ehdr;
